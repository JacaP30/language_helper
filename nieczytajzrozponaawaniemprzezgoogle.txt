# language_helper/app2.py na bibliotece speech_recognition
# Tłumaczenie z wybranych języków.
# możliwość dodawania wiadomości w języku obcym i poprawiania błędów
# translator z rozpoznawaniem mowy i odtwarzaniem
# dodać wybór agentów (podstawowy i zaawansowany)
import streamlit as st
from dotenv import dotenv_values
from openai import OpenAI
import speech_recognition as sr
from gtts import gTTS
import os

# Wczytanie zmiennych środowiskowych z pliku .env 
def load_environment():
    """Ładuje zmienne środowiskowe z pliku .env"""
    env = dotenv_values(".env")
    if not env.get("OPENAI_API_KEY"):
        st.error("❌ Brak klucza API OpenAI w pliku .env")
        st.stop()
    return env

env = load_environment()  # <--
client = OpenAI(api_key=env.get("OPENAI_API_KEY"))


# Lista obsługiwanych języków ( można rozszerzyć)
supported_languages = ["angielski", "polski", "niemiecki", "francuski", "hiszpański", "włoski"]

st.title("PLLA - personal language learning assistant")

with st.sidebar:
    tool_language = st.selectbox(
        "Wybierz narzędzie",
        [
            "Translator", # tłumacz ZROBIONE
            "Belfer", # sprawdza poprawność zdań ZROBIONE
            "Jak powiem?", # pomaga budować zagadnienia
            "Dialog" # prowadzi dialog (dorobić wybór tematów.)
        ], key="tool_language"
    )



       
# ===============================================
# Translator
if tool_language == "Translator":
    st.header("Translator językowy")

     # wybór języka wprowadzonego tekstu
    language_in= st.selectbox("Wybierz język tekstu do tłumaczenia:", supported_languages, key="language_in")
    # ustawienie języka kodu dla rozpoznawania mowy
    language_in_code_map = {
        "angielski": "en-US",
        "polski": "pl-PL",
        "niemiecki": "de-DE",
        "francuski": "fr-FR",
        "hiszpański": "es-ES",
        "włoski": "it-IT"
    }       
    language_in_code = language_in_code_map.get(language_in, "pl-PL")  # Domyślnie polski

    # Pole tekstowe do wpisania wiadomości
    if "recognized_text" not in st.session_state:
        st.session_state["recognized_text"] = ""

    translate_text = st.text_area(
        "Wpisz tekst do tłumaczenia w wybranym języku lub nagraj rozmowę:",
        value=st.session_state["recognized_text"],
        key="translate_text_area"
    )

    # Funkcja do rozpoznawania mowy
    def recognize_speech(language=language_in_code):
        recognizer = sr.Recognizer()
        with sr.Microphone() as source:
            st.write("🎤 Mów teraz...")
            audio = recognizer.listen(source)
            try:
                text = recognizer.recognize_google(audio, language=language)
                return text
            except sr.UnknownValueError:
                return "Nie udało się rozpoznać mowy."
            except sr.RequestError as e:
                return f"Błąd podczas rozpoznawania: {e}"

    # Sekcja rozpoznawania mowy
    if st.button("Nagraj mowę"):
        recognized_text = recognize_speech(language=language_in_code)
        st.session_state["recognized_text"] = recognized_text
        st.rerun()  # Odśwież aplikację, by zaktualizować pole tekstowe

    # wybór języka tłumaczenia
    language_out= st.selectbox("Wybierz język tłumaczenia:", supported_languages, key="language_out")

    language_out_code_map = {
        "angielski": "en",
        "polski": "pl",
        "niemiecki": "de",
        "francuski": "fr",
        "hiszpański": "es",
        "włoski": "it"
    }   
    language_out_code = language_out_code_map.get(language_out, "pl")  # Domyślnie polski

    # Funkcja do generowania mowy i zwracania ścieżki do pliku
    def text_to_speech(text, language=language_out_code):
        tts = gTTS(text=text, lang=language)
        tts.save("output.mp3")
        with open("output.mp3", "rb") as audio_file:
            audio_bytes = audio_file.read()
        return audio_bytes

    # Przechowywanie tłumaczenia w session_state
    if "last_translation" not in st.session_state:
        st.session_state["last_translation"] = ""
    if "last_audio" not in st.session_state:
        st.session_state["last_audio"] = None

    # Wyświetl tłumaczenie, jeśli istnieje
    if st.session_state.get("last_translation"):
        st.subheader(f"Tłumaczenie na {language_out}:")
        st.write(st.session_state["last_translation"])

    if st.button("Przetłumacz na wybrany język"):
        if not st.session_state["translate_text_area"].strip():
            st.warning("Proszę wpisać tekst do przetłumaczenia lub nagrać mowę.")
        else:
            # Wywołanie OpenAI API do tłumaczenia
            prompt = f"Przetłumacz na {language_out} następujący tekst:\n{st.session_state['translate_text_area']}"
            try:
                response = client.chat.completions.create(
                    model="gpt-4o-mini",
                    messages=[
                        {"role": "system", "content": f"Jesteś pomocnym tłumaczem zjęzyka {language_in} na język {language_out}. Jeśli tekst jest już w wybranym języku {language_out}, odpowiedz 'Tekst jest już w wybranym języku.', Jeśli tekst jest w innym języku niż {supported_languages}, odpowiedz 'Język podanego tekstu nie jest obsługiwany.' "},
                        {"role": "user", "content": prompt}
                    ],
                    max_tokens=500,
                    temperature=0.1,
                )
                content = response.choices[0].message.content
                translation = content.strip() if content is not None else ""
                st.session_state["last_translation"] = translation  # Zapisz tłumaczenie do session_state
                st.subheader(f"Tłumaczenie na {language_out}:")
                st.write(translation)
                # Generuj audio automatycznie po tłumaczeniu
                st.session_state["last_audio"] = text_to_speech(translation, language=language_out_code)
            except Exception as e:
                st.error(f"Wystąpił błąd podczas tłumaczenia: {e}")

    # Odtwarzanie ostatniego tłumaczenia z session_state
    if st.button("Odtwórz wymowę"):
        if st.session_state.get("last_translation"):
            if st.session_state.get("last_audio") is None:
                st.session_state["last_audio"] = text_to_speech(st.session_state["last_translation"], language=language_out_code)
            st.audio(st.session_state["last_audio"], format="audio/mp3")
        else:
            st.warning("Brak tłumaczenia do odtworzenia. Najpierw przetłumacz tekst.")

# =====================================================================
# poprawianie pisowni i gramatyki
elif tool_language == "Belfer":
    st.header("Sprawdzanie budowy zdań z poprawkami i tłumaczeniem")

    #
    # Sekcja weryfikacji
    # wybór języka weryfikcji
    verification_language = st.selectbox("Wybierz język weryfikacji:", supported_languages, key="verification_language")

    # Pole tekstowe do wpisania wiadomości
    verified_text = st.text_area("Wpisz tekst do weryfikacji w obsługiwanym języku:")

    verification_language_translate = st.selectbox("Wybierz język tłumaczenia weryfikacji:", supported_languages, index=1, key="verification_language_translate")
    
    if st.button("Zweryfikuj"):
        if verified_text is None or (hasattr(verified_text, "strip") and not verified_text.strip()):
            st.warning("Proszę wpisać tekst do weryfikacji.")
            
        else:
            # Wywołanie OpenAI API do tłumaczenia
            prompt = f"Sprawdź poprawność użytych wyrazów, budowę zdania i gramatykę w języku {verification_language} następujący tekst:\n{verified_text}. Zaproponuj zmiany i poprawki wraz z wyjaśnieniami. Na koniec podaj tłumaczenie na  "
            try:
                response = client.chat.completions.create(
                    model="gpt-4o-mini",
                    messages=[
                        {"role": "system", "content": f"Jesteś nauczycielem języka w języku {verification_language}. Jasno i zwięźle wyjaśniasz zagadnienia językowe związane z wpisanym tekstem i wyjaśniasz błędy. Jeśli tekst jest w innym języku niż {supported_languages}, odpowiedz 'Język podanego tekstu nie jest obsługiwany.' "},
                        {"role": "user", "content": prompt}
                    ],
                    max_tokens=1000,
                    temperature=0.1,
                )
                content = response.choices[0].message.content
                verification = content.strip() if content is not None else ""
                st.subheader(f"Weryfikacja i wyjaśnienie:")
                st.write(verification)

                # sprawdzenie urzycia tokenów
                usage = {}
                if response.usage:
                    usage = {
                        "prompt_tokens": response.usage.prompt_tokens,
                        "completion_tokens": response.usage.completion_tokens,
                        "total_tokens": response.usage.total_tokens,
                    }
                st.write(f"Użyto {usage.get('prompt_tokens', 0)} tokenów wejściowych i {usage.get('completion_tokens', 0)} tokenów wyjściowych. Razem: {usage.get('total_tokens', 0)} tokenów.")   

            except Exception as e:
                st.error(f"Wystąpił błąd podczas tłumaczenia: {e}")
    
# =====================================================================