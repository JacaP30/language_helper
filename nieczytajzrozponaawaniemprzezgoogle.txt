# language_helper/app2.py na bibliotece speech_recognition
# TÅ‚umaczenie z wybranych jÄ™zykÃ³w.
# moÅ¼liwoÅ›Ä‡Â dodawania wiadomoÅ›ci w jÄ™zyku obcym i poprawiania bÅ‚Ä™dÃ³w
# translator z rozpoznawaniem mowy i odtwarzaniem
# dodaÄ‡ wybÃ³r agentÃ³w (podstawowy i zaawansowany)
import streamlit as st
from dotenv import dotenv_values
from openai import OpenAI
import speech_recognition as sr
from gtts import gTTS
import os

# Wczytanie zmiennych Å›rodowiskowych z pliku .env 
def load_environment():
    """Åaduje zmienne Å›rodowiskowe z pliku .env"""
    env = dotenv_values(".env")
    if not env.get("OPENAI_API_KEY"):
        st.error("âŒ Brak klucza API OpenAI w pliku .env")
        st.stop()
    return env

env = load_environment()  # <--
client = OpenAI(api_key=env.get("OPENAI_API_KEY"))


# Lista obsÅ‚ugiwanych jÄ™zykÃ³w ( moÅ¼na rozszerzyÄ‡)
supported_languages = ["angielski", "polski", "niemiecki", "francuski", "hiszpaÅ„ski", "wÅ‚oski"]

st.title("PLLA - personal language learning assistant")

with st.sidebar:
    tool_language = st.selectbox(
        "Wybierz narzÄ™dzie",
        [
            "Translator", # tÅ‚umacz ZROBIONE
            "Belfer", # sprawdza poprawnoÅ›Ä‡ zdaÅ„ ZROBIONE
            "Jak powiem?", # pomaga budowaÄ‡ zagadnienia
            "Dialog" # prowadzi dialog (dorobiÄ‡ wybÃ³r tematÃ³w.)
        ], key="tool_language"
    )



       
# ===============================================
# Translator
if tool_language == "Translator":
    st.header("Translator jÄ™zykowy")

     # wybÃ³r jÄ™zyka wprowadzonego tekstu
    language_in= st.selectbox("Wybierz jÄ™zyk tekstu do tÅ‚umaczenia:", supported_languages, key="language_in")
    # ustawienie jÄ™zyka kodu dla rozpoznawania mowy
    language_in_code_map = {
        "angielski": "en-US",
        "polski": "pl-PL",
        "niemiecki": "de-DE",
        "francuski": "fr-FR",
        "hiszpaÅ„ski": "es-ES",
        "wÅ‚oski": "it-IT"
    }       
    language_in_code = language_in_code_map.get(language_in, "pl-PL")  # DomyÅ›lnie polski

    # Pole tekstowe do wpisania wiadomoÅ›ci
    if "recognized_text" not in st.session_state:
        st.session_state["recognized_text"] = ""

    translate_text = st.text_area(
        "Wpisz tekst do tÅ‚umaczenia w wybranym jÄ™zyku lub nagraj rozmowÄ™:",
        value=st.session_state["recognized_text"],
        key="translate_text_area"
    )

    # Funkcja do rozpoznawania mowy
    def recognize_speech(language=language_in_code):
        recognizer = sr.Recognizer()
        with sr.Microphone() as source:
            st.write("ğŸ¤ MÃ³w teraz...")
            audio = recognizer.listen(source)
            try:
                text = recognizer.recognize_google(audio, language=language)
                return text
            except sr.UnknownValueError:
                return "Nie udaÅ‚o siÄ™ rozpoznaÄ‡ mowy."
            except sr.RequestError as e:
                return f"BÅ‚Ä…d podczas rozpoznawania: {e}"

    # Sekcja rozpoznawania mowy
    if st.button("Nagraj mowÄ™"):
        recognized_text = recognize_speech(language=language_in_code)
        st.session_state["recognized_text"] = recognized_text
        st.rerun()  # OdÅ›wieÅ¼ aplikacjÄ™, by zaktualizowaÄ‡ pole tekstowe

    # wybÃ³r jÄ™zyka tÅ‚umaczenia
    language_out= st.selectbox("Wybierz jÄ™zyk tÅ‚umaczenia:", supported_languages, key="language_out")

    language_out_code_map = {
        "angielski": "en",
        "polski": "pl",
        "niemiecki": "de",
        "francuski": "fr",
        "hiszpaÅ„ski": "es",
        "wÅ‚oski": "it"
    }   
    language_out_code = language_out_code_map.get(language_out, "pl")  # DomyÅ›lnie polski

    # Funkcja do generowania mowy i zwracania Å›cieÅ¼ki do pliku
    def text_to_speech(text, language=language_out_code):
        tts = gTTS(text=text, lang=language)
        tts.save("output.mp3")
        with open("output.mp3", "rb") as audio_file:
            audio_bytes = audio_file.read()
        return audio_bytes

    # Przechowywanie tÅ‚umaczenia w session_state
    if "last_translation" not in st.session_state:
        st.session_state["last_translation"] = ""
    if "last_audio" not in st.session_state:
        st.session_state["last_audio"] = None

    # WyÅ›wietl tÅ‚umaczenie, jeÅ›li istnieje
    if st.session_state.get("last_translation"):
        st.subheader(f"TÅ‚umaczenie na {language_out}:")
        st.write(st.session_state["last_translation"])

    if st.button("PrzetÅ‚umacz na wybrany jÄ™zyk"):
        if not st.session_state["translate_text_area"].strip():
            st.warning("ProszÄ™ wpisaÄ‡ tekst do przetÅ‚umaczenia lub nagraÄ‡ mowÄ™.")
        else:
            # WywoÅ‚anie OpenAI API do tÅ‚umaczenia
            prompt = f"PrzetÅ‚umacz na {language_out} nastÄ™pujÄ…cy tekst:\n{st.session_state['translate_text_area']}"
            try:
                response = client.chat.completions.create(
                    model="gpt-4o-mini",
                    messages=[
                        {"role": "system", "content": f"JesteÅ› pomocnym tÅ‚umaczem zjÄ™zyka {language_in} na jÄ™zyk {language_out}. JeÅ›li tekst jest juÅ¼ w wybranym jÄ™zyku {language_out}, odpowiedz 'Tekst jest juÅ¼ w wybranym jÄ™zyku.', JeÅ›li tekst jest w innym jÄ™zyku niÅ¼ {supported_languages}, odpowiedz 'JÄ™zyk podanego tekstu nie jest obsÅ‚ugiwany.' "},
                        {"role": "user", "content": prompt}
                    ],
                    max_tokens=500,
                    temperature=0.1,
                )
                content = response.choices[0].message.content
                translation = content.strip() if content is not None else ""
                st.session_state["last_translation"] = translation  # Zapisz tÅ‚umaczenie do session_state
                st.subheader(f"TÅ‚umaczenie na {language_out}:")
                st.write(translation)
                # Generuj audio automatycznie po tÅ‚umaczeniu
                st.session_state["last_audio"] = text_to_speech(translation, language=language_out_code)
            except Exception as e:
                st.error(f"WystÄ…piÅ‚ bÅ‚Ä…d podczas tÅ‚umaczenia: {e}")

    # Odtwarzanie ostatniego tÅ‚umaczenia z session_state
    if st.button("OdtwÃ³rz wymowÄ™"):
        if st.session_state.get("last_translation"):
            if st.session_state.get("last_audio") is None:
                st.session_state["last_audio"] = text_to_speech(st.session_state["last_translation"], language=language_out_code)
            st.audio(st.session_state["last_audio"], format="audio/mp3")
        else:
            st.warning("Brak tÅ‚umaczenia do odtworzenia. Najpierw przetÅ‚umacz tekst.")

# =====================================================================
# poprawianie pisowni i gramatyki
elif tool_language == "Belfer":
    st.header("Sprawdzanie budowy zdaÅ„ z poprawkami i tÅ‚umaczeniem")

    #
    # Sekcja weryfikacji
    # wybÃ³r jÄ™zyka weryfikcji
    verification_language = st.selectbox("Wybierz jÄ™zyk weryfikacji:", supported_languages, key="verification_language")

    # Pole tekstowe do wpisania wiadomoÅ›ci
    verified_text = st.text_area("Wpisz tekst do weryfikacji w obsÅ‚ugiwanym jÄ™zyku:")

    verification_language_translate = st.selectbox("Wybierz jÄ™zyk tÅ‚umaczenia weryfikacji:", supported_languages, index=1, key="verification_language_translate")
    
    if st.button("Zweryfikuj"):
        if verified_text is None or (hasattr(verified_text, "strip") and not verified_text.strip()):
            st.warning("ProszÄ™ wpisaÄ‡ tekst do weryfikacji.")
            
        else:
            # WywoÅ‚anie OpenAI API do tÅ‚umaczenia
            prompt = f"SprawdÅº poprawnoÅ›Ä‡ uÅ¼ytych wyrazÃ³w, budowÄ™ zdania i gramatykÄ™ w jÄ™zyku {verification_language} nastÄ™pujÄ…cy tekst:\n{verified_text}. Zaproponuj zmiany i poprawki wraz z wyjaÅ›nieniami. Na koniec podaj tÅ‚umaczenie na  "
            try:
                response = client.chat.completions.create(
                    model="gpt-4o-mini",
                    messages=[
                        {"role": "system", "content": f"JesteÅ› nauczycielem jÄ™zyka w jÄ™zyku {verification_language}. Jasno i zwiÄ™Åºle wyjaÅ›niasz zagadnienia jÄ™zykowe zwiÄ…zane z wpisanym tekstem i wyjaÅ›niasz bÅ‚Ä™dy. JeÅ›li tekst jest w innym jÄ™zyku niÅ¼ {supported_languages}, odpowiedz 'JÄ™zyk podanego tekstu nie jest obsÅ‚ugiwany.' "},
                        {"role": "user", "content": prompt}
                    ],
                    max_tokens=1000,
                    temperature=0.1,
                )
                content = response.choices[0].message.content
                verification = content.strip() if content is not None else ""
                st.subheader(f"Weryfikacja i wyjaÅ›nienie:")
                st.write(verification)

                # sprawdzenie urzycia tokenÃ³w
                usage = {}
                if response.usage:
                    usage = {
                        "prompt_tokens": response.usage.prompt_tokens,
                        "completion_tokens": response.usage.completion_tokens,
                        "total_tokens": response.usage.total_tokens,
                    }
                st.write(f"UÅ¼yto {usage.get('prompt_tokens', 0)} tokenÃ³w wejÅ›ciowych i {usage.get('completion_tokens', 0)} tokenÃ³w wyjÅ›ciowych. Razem: {usage.get('total_tokens', 0)} tokenÃ³w.")   

            except Exception as e:
                st.error(f"WystÄ…piÅ‚ bÅ‚Ä…d podczas tÅ‚umaczenia: {e}")
    
# =====================================================================